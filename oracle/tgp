#!/usr/bin/env Rscript
suppressPackageStartupMessages(require(tgp, quietly=T))
suppressPackageStartupMessages(require(lhs, quietly=T))

#### Define some utility functions
# Import the uniform sampling scheme that is writing in C
dyn.load(file.path(Sys.getenv("ASKHOME"), "common/libuniformsampling.so"))

tgp_sample <- function(X, Z, available, n) {
  tgpout <- btgpllm(X, Z, verb=T)
  design = tgp.design(n, available, tgpout)
  # strangely tgp.design returns more points than n
  return(design[1:n,])
}

# Parse the arguments
require(rjson, quietly=T)

args <- commandArgs(trailingOnly = T)

if (length(args) != 3) {
    stop("Usage: file <configuration.conf> <input_file> <output_file>")
}

configuration = fromJSON(paste(readLines(args[1]), collapse=""))

# Read the data
ordefault <- function(v,d) {
  if(is.null(v)) return(d) else return(v)
}

data = read.table(args[2])
nsamples= ordefault(configuration$modules$oracle$params$n,10)

# Generate all available points and set up categorical variables
# as factors
lf = list()
i = 1
mins = c()
maxs = c()
for (f in configuration$factors) {
  if (f$type == "categorical") {
    stop("categorical data not yet supported in tgp module")
  } else {
    mins = c(mins, f$range$min)
    maxs = c(maxs, f$range$max)
  }
  i = i+1
}

available <- lhs(4*nsamples, cbind(mins,maxs))

i = 1
for (f in configuration$factors) {
    if (f$type == "integer") {
        available[,i] = as.integer(available[,i])
    }
    i = i+1
}

# Rename available columns from Vari -> Vi so they are consistent
# with the input
i = 1
for (f in configuration$factors) {
  names(available)[names(available)==paste("Var",i,sep="")] <- paste("V",i,sep="")
  i = i + 1
}

# split data in explicative variables, X, and response, Z.  
X = data[,-ncol(data)] 
Z = data[,ncol(data)]

newsamples <- tgp_sample(X, Z, available,n=nsamples)

write.table(newsamples,
            file=args[3],
            row.names=F,
            col.names=F)
